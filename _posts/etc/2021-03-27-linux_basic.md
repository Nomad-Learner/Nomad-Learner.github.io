---
layout: post
title:  "linux 기본 명령어 사용법"
subtitle:   "tip for linux"
categories: etc
tags: etc
comments: true
---

#### 1.
pwd : print working directory -> 모든 사용자 디렉토리는 /home/ 밑에 있다. 현재 작업하고 있는 디렉터리를 알려준다.


####  2.
ls : 디렉토리와 파일명만 뜬다. 이때는 가로로 뜬다.
ls -l: 접근권환까지 해서 디렉토리와 파일명이 뜬다. (세로로 뜬다)
ls -al: linux에서 파일명이 .으로 시작하면 숨김 파일이라는 뜻. a 옵션 덕에 숨김파일까지 같이 뜬다.

오른쪽-> 왼쪽으로 파일명-생성 혹은 최종 수정 시간- 바이트로 나타낸 용량- 그룹계정/소유자계정 - 접근권환

접근권환에서 맨 앞이

- : file
d : dirextory
I : Link
첫번째 rwx(사용자) 두번째 rwx(그룹) 세번쨰(other)의 권한
==> 3bit로 표현해준다.

#### 3.
chmod: 파일의 접근권한 변경. 777일 때가 rwx rwx rwx인 상황
chmod 664 a.out 이런식으로 쓴다

####  4.
mkdir 디렉토리명: 디렉토리가 만들어진다

#### 5.
touch 파일명: 파일이 만들어진다

####  6.
rm -f 파일명: 파일삭제

#### 7.
rm -R 디렉토리명: 디렉토리삭제

linux는 최상위 디렉토리 / 를 기준으로 하위 디렉토리가 만들어지는 구조이다. /는 절대 경로이다.
/root
/home 은 기본으로 있다

linux에 계정을 생성하면(예를들어 guest1) /home/guest1이 생성된다. 즉 home 디렉토리 밑에 계정별로 디렉토리가 생긴다.

절대경로 vs 상대경로

/ 는 절대 위치를 기준으로 잡아준다(절대경로-리눅스 최상위 디렉토리가 기준이 된다)
./ 는 현재 위치를 기준으로 잡아준다(상대경로)
../ 는 현재 위치 디렉토리의 상위 디렉토리를 기준으로 잡는다(상대경로)- 이전 디렉토리를 의미한다 생각하기
~/ 자신의 home 디렉토리를 기준으로 한다.(상대경로)

####  8.
cd 디렉토리명 : 디렉토리 이동

guest1 계정에서 dir1 디렉토리로 이동하는 3가지 방법

절대 경로 기준: cd /home/guest1/dir1  ==> 최상위 디렉토리 / 아래 있는 home 아래 있는 guest1 아래 있는 dir1으로 이동하겠다.
현재 경로 기준: cd ./dir1 ==> 현재 guest1 디렉토리 아래에 있는 dir1 디렉토리로 이동하겠다
홈 경로 기준: cd ~/dir1 ==> home 디렉토리 아래에 있는 dir1 디렉토리로 이동하겠다.

~/ 이거하면 /home/guest1/ 이거를 앞에 적은거랑 같은 효과인것 같다.

이전 디렉토리 가려면?
cd ../ 하면 이전 디렉토리로 돌아간다
cd / 하면 최상위 디렉토리로 간다
/ 에서 cd만 하면 나의 home 디렉토리로 바로 갈 수 있다.

cd ~/

####  9.
mv 이름1 이름2: 파일명이나 디렉토리명을 이름1에서 이름2로 바꿀 수 있다

mv 이름1 경로1: 이름1을 가진 파일을 경로1로 이동시킬 수 있다.


####  10.
cp 이름1 이름2: 이름1을 가진 파일을 이름2로 바꿔서 복사한다. (copy의 준말)

cp 이름1 경로1: 이름1을 가진 파일을 복사해서 경로1에 둔다

cp -r 이름1 이름2: 이름1을 가진 디렉토리를 이름2로 바꿔서 복사한다


우리가 익숙한 형태로 파일정리하는 것: Link File
실제 컴퓨터 물리적인 하드디스크에 들어가 있는 형태: Filesystem
일반적으로 Link File과 Filesystem은 inode라는 것을 이용해서 서로간의 파일정보가 1 : 1로 맵핑되어 있다.
inode는 파일이 생성되면 파일마다 부여되는 고유한 식별번호이다.
Filesystem은 inode-Ref-Data로 구성된다.
Ref는 실제 파일시스템을 참조하는 Link File의 개수를 의미한다. 이 inode를 가진 파일을 참조하는 Link File이 몇개인가
Ref가 0이 되면 OS가 해당 파일을 하드에서 지운다.

ex) 내가 이력서1.doc를 더블 클릭하면 컴퓨터는 링크파일인 이력서1.doc가 가지고 있는 inode 번호와 일치하는 inode 번호를
물리적인 하드의 Filesystem에서 찾아 실행한다.

하드 링크는 LinkFile에서 원본 파일을 복사해서 복사본을 만듦과 동시에 원본파일과 복사본이 동일한 inode 번호를 갖게 한다.
원본 파일과 복사본 파일이 FIlesystem에서 동일한 inode를 가지게 된다(마치 C++ 얕은복사 하듯이)
원본 파일 inode가 3이면 복사본 inode도 3인 상황으로 만든다. Filesystem 입장에선 inode가 3인 파일을 2개의 파일이 참조하고 있는 상황
Ref는 2가 된다.
===> 원본이든 복사본이든 수정이 일어나면 모든 파일이 동시에 수정된다. 왜냐하면 Filesystem에서 서로 같은 파일을 바라보고 있으니까.
즉 하드링크가 형성되면 원본/복사본 개념이 사라진다. 어떤 파일을 건드려도 다 같이 수정되기 때문이다.
수정과 별개로 삭제는 하나만 된다. Ref가 2에서 1로 까일 뿐이지 Filesystem에는 여전히 남아있는 상황
하드링크 파일이 형성되면 Filesystem에서 해당 inode의 Ref값을 +1
하드링크 파일이 삭제되면 FIlesystem에서 해당 inode의 Ref값을 -1
수정은 다같이 이뤄진다.
하드링크는 파일에서만 설정가능하다.

소프트링크: 윈도우의 바로가기 같은 기능. 링크파일이 링크파일을 참조하는 형태. 파일과 디렉토리 모두에 설정가능하다.
오픈소스 개발할 때 많이 쓰인다. 소프트링크가 일어나면 Filesystem의 inode에는 서로 다른 값이 들어가 있는 것이다.


####  11.
ln -s 이름1 이름2: 소프트링크 만드는 법. 이름1을 가진 파일/디렉토리에 대해 이름2를 가진 소프트링크 파일을 만들겠다.

ln 이름1 이름2: 하드링크 만드는 법. 이름1을 가진 파일에 대해 이름2를 가진 하드링크를 만들겠다.
-> 하드링크를 구분하기 위해서는

####  12.
ls -ali 처럼 i 옵션이 필요하다. i를 통해 파일과 디렉토리가 가지고 있는 inode 값을 알 수 있다.


#### 13.
cat 파일명 | more : 파일 내용을 한 화면안에 출력해준다. space를 누르면 다음페이지로 간다.

cat 파일명1 > 파일명2: 파일명1의 내용을 파일명2로 덮어쓰기 해준다. 파일명2에 해당하는 파일이 없으면 파일을 생성시켜준다.

cat 파일명1 >> 파일명2: 파일명1의 내용을 파일명2의 마지막 부분에 이어쓰기 해준다(마지막 부분에 복사)

#####  >> 이거 자체가 파일의 마지막 부분에 이어쓰기 하는 역할이 있다.

####  14.
head 파일명1: 파일의 시작부분

tail 파일명1: 파일의 끝부분을 화면에 출력해준다.

tail -n 숫자1 파일명1: 파일명1의 끝부분에서 숫자1만큼 화면에 출력

tail -f 파일명1: 파일명1의 마지막에 데이터가 추가되는 즉시 화면에 출력해준다. 로그파일에 많이 쓰인다.

####  15.
grep 문자열1 파일이름1: 문자열1을 가지고 파일이름1을 가진 파일을 검색해준다

grep -H 문자열1 파일이름1: 어떤 파일이 문자열1을 가지고 있는지도 나온다.

ex) grep -H test *.txt ==> test라는 문자열을 가지고 파일의 끝이 .txt로 끝나는 파일들을 전부 찾아줘

grep -Hw 문자열1 파일이름1: 정확하게 문자열1을 가지고 있는 파일을 보여준다.

####  16.
less 파일명1: 파일명1의 내용을 읽기 전용으로 연다. 용량이 큰 로그파일은 무조건 less로 열어야 CPU등 자원 낭비를 막을 수
있다. q 누르면 빠져나올 수 있다.

####  ==============================  이제부터 시스템 명령어 ==================================

####  17.
tar cvfz 압축파일명.tar.gz 디렉토리명1: tar cvfz는 한 set로 외우고 압축할 파일과 디렉토리명들은 스페이스로 구분지으면 된다

tar xvfz 압축파일명.tar.gz: 압축파일안에 있는 내용을 풀 수 있다.

####  18.
root = sudo (최고 권력자는 root)
sudo 명령어 옵션

####  19.
sudo chown 새로운소유자:새로운그룹 대상파일1: 대상파일1이 새로운소유자와 새로운그룹의 것으로 바뀐다

ex) sudo chown iskra:iskra test.c 이런식

#### 20.
파일이나 디렉토리에 관한 모든 옵션으로 위치를 찾을 수 있는 강력한 찾기 명령어 find

find 경로 조건 target

####  21.
명령어 위치 검색
which 명령어: ex) which ls 이런식으로

####  22.
CPU와 메모리 상태 알아보는 명령어
top

####  23.
 현재 리눅스 서버에 접속중인 사용자 확인하는 명령어
w, who

####  24.
인터넷이 연결되어 있는지 확인하기 ping 도메인주소 혹은 ping ip 주소
ping google.com

####  25.
IP 주소 확인하는 명령어
nslookup
nslookup domain

#### 26.
현재 리눅스에서 돌아가는 프로세스 정보 출력: ps
ps -ef
ps -ef | grep 문자열
프로세서(processor) == CPU, 프로세스(process) == 메모리위에서 돌아가는 프로그램

#### 27.
kill -9 프로세스ID: 프로세스를 강제 종료 할 수 있다.
프로세스 ID는 ps -ef를 한 후 왼쪽에서 두번째에 있는 PID를 확인하면 된다. PPID는 부모의 프로세스 번호이다

####  28.
sudo adduser 사용자ID: 새로운 사용자 추가

이렇게 추가하면 /home 아래에 새로운 계정 디렉토리가 생성된다.

#### 29.
su -l 사용자2: 현재 사용자1로 로그인 되어 있는 것을 사용자2로 바꿔서 로그인한다.
exit: 현재 사용자에서 로그아웃 하는 방법

#### 30.
sudo deluser 사용자ID: 사용자 삭제(디렉토리는 남아있다)
sudo rm -rf 디렉토리: 디렉토리를 다 지운다.

####  31.
uname -a: 시스템 정보 확인
hostname: 이 서버의 별명
sudo reboot: 시스템 다시 시작
sudo halt -p: 시스템 완전 종료

#### ====================================
clear 치면 명령어 창이 깨끗해진다
explorer.exe . 치면 내가 익숙한 GUI 윈도우가 뜬다
man 명령어: 도움말 알 수 있다.
man 3 라이브러리[함수명]: 프로그래밍 개발에 필요한 함수들을 알려준다


출처
https://www.youtube.com/watch?v=9_KIdQ8abH4&list=PL6h-5hNOYbqoC96XlIfLWFHmcm3JWdoUG&index=7
https://m.blog.naver.com/PostView.nhn?blogId=qbxlvnf11&logNo=221407173643&proxyReferer=https:%2F%2Fwww.google.com%2F
